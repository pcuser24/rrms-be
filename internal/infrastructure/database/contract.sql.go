// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: contract.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createContract = `-- name: CreateContract :one
INSERT INTO "contracts" (
  rental_id,
  a_fullname,
  a_dob,
  a_phone,
  a_address,
  a_household_registration,
  a_identity,
  a_identity_issued_by,
  a_identity_issued_at,
  a_documents,
  a_bank_account,
  a_bank,
  a_registration_number,
  b_fullname,
  b_phone,
  payment_method,
  n_copies,
  created_at_place,
  content,
  created_at,
  updated_at,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19,
  NOW(),
  NOW(),
  $20,
  $20
) RETURNING id, rental_id, a_fullname, a_dob, a_phone, a_address, a_household_registration, a_identity, a_identity_issued_by, a_identity_issued_at, a_documents, a_bank_account, a_bank, a_registration_number, b_fullname, b_organization_name, b_organization_hq_address, b_organization_code, b_organization_code_issued_at, b_organization_code_issued_by, b_dob, b_phone, b_address, b_household_registration, b_identity, b_identity_issued_by, b_identity_issued_at, b_bank_account, b_bank, b_tax_code, payment_method, n_copies, created_at_place, content, status, created_at, updated_at, created_by, updated_by
`

type CreateContractParams struct {
	RentalID               int64       `json:"rental_id"`
	AFullname              string      `json:"a_fullname"`
	ADob                   pgtype.Date `json:"a_dob"`
	APhone                 string      `json:"a_phone"`
	AAddress               string      `json:"a_address"`
	AHouseholdRegistration string      `json:"a_household_registration"`
	AIdentity              string      `json:"a_identity"`
	AIdentityIssuedBy      string      `json:"a_identity_issued_by"`
	AIdentityIssuedAt      pgtype.Date `json:"a_identity_issued_at"`
	ADocuments             []string    `json:"a_documents"`
	ABankAccount           pgtype.Text `json:"a_bank_account"`
	ABank                  pgtype.Text `json:"a_bank"`
	ARegistrationNumber    string      `json:"a_registration_number"`
	BFullname              string      `json:"b_fullname"`
	BPhone                 string      `json:"b_phone"`
	PaymentMethod          string      `json:"payment_method"`
	NCopies                int32       `json:"n_copies"`
	CreatedAtPlace         string      `json:"created_at_place"`
	Content                pgtype.Text `json:"content"`
	UserID                 uuid.UUID   `json:"user_id"`
}

func (q *Queries) CreateContract(ctx context.Context, arg CreateContractParams) (Contract, error) {
	row := q.db.QueryRow(ctx, createContract,
		arg.RentalID,
		arg.AFullname,
		arg.ADob,
		arg.APhone,
		arg.AAddress,
		arg.AHouseholdRegistration,
		arg.AIdentity,
		arg.AIdentityIssuedBy,
		arg.AIdentityIssuedAt,
		arg.ADocuments,
		arg.ABankAccount,
		arg.ABank,
		arg.ARegistrationNumber,
		arg.BFullname,
		arg.BPhone,
		arg.PaymentMethod,
		arg.NCopies,
		arg.CreatedAtPlace,
		arg.Content,
		arg.UserID,
	)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.RentalID,
		&i.AFullname,
		&i.ADob,
		&i.APhone,
		&i.AAddress,
		&i.AHouseholdRegistration,
		&i.AIdentity,
		&i.AIdentityIssuedBy,
		&i.AIdentityIssuedAt,
		&i.ADocuments,
		&i.ABankAccount,
		&i.ABank,
		&i.ARegistrationNumber,
		&i.BFullname,
		&i.BOrganizationName,
		&i.BOrganizationHqAddress,
		&i.BOrganizationCode,
		&i.BOrganizationCodeIssuedAt,
		&i.BOrganizationCodeIssuedBy,
		&i.BDob,
		&i.BPhone,
		&i.BAddress,
		&i.BHouseholdRegistration,
		&i.BIdentity,
		&i.BIdentityIssuedBy,
		&i.BIdentityIssuedAt,
		&i.BBankAccount,
		&i.BBank,
		&i.BTaxCode,
		&i.PaymentMethod,
		&i.NCopies,
		&i.CreatedAtPlace,
		&i.Content,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getContractByID = `-- name: GetContractByID :one
SELECT id, rental_id, a_fullname, a_dob, a_phone, a_address, a_household_registration, a_identity, a_identity_issued_by, a_identity_issued_at, a_documents, a_bank_account, a_bank, a_registration_number, b_fullname, b_organization_name, b_organization_hq_address, b_organization_code, b_organization_code_issued_at, b_organization_code_issued_by, b_dob, b_phone, b_address, b_household_registration, b_identity, b_identity_issued_by, b_identity_issued_at, b_bank_account, b_bank, b_tax_code, payment_method, n_copies, created_at_place, content, status, created_at, updated_at, created_by, updated_by FROM "contracts" WHERE "id" = $1
`

func (q *Queries) GetContractByID(ctx context.Context, id int64) (Contract, error) {
	row := q.db.QueryRow(ctx, getContractByID, id)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.RentalID,
		&i.AFullname,
		&i.ADob,
		&i.APhone,
		&i.AAddress,
		&i.AHouseholdRegistration,
		&i.AIdentity,
		&i.AIdentityIssuedBy,
		&i.AIdentityIssuedAt,
		&i.ADocuments,
		&i.ABankAccount,
		&i.ABank,
		&i.ARegistrationNumber,
		&i.BFullname,
		&i.BOrganizationName,
		&i.BOrganizationHqAddress,
		&i.BOrganizationCode,
		&i.BOrganizationCodeIssuedAt,
		&i.BOrganizationCodeIssuedBy,
		&i.BDob,
		&i.BPhone,
		&i.BAddress,
		&i.BHouseholdRegistration,
		&i.BIdentity,
		&i.BIdentityIssuedBy,
		&i.BIdentityIssuedAt,
		&i.BBankAccount,
		&i.BBank,
		&i.BTaxCode,
		&i.PaymentMethod,
		&i.NCopies,
		&i.CreatedAtPlace,
		&i.Content,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getContractByRentalID = `-- name: GetContractByRentalID :one
SELECT id, rental_id, a_fullname, a_dob, a_phone, a_address, a_household_registration, a_identity, a_identity_issued_by, a_identity_issued_at, a_documents, a_bank_account, a_bank, a_registration_number, b_fullname, b_organization_name, b_organization_hq_address, b_organization_code, b_organization_code_issued_at, b_organization_code_issued_by, b_dob, b_phone, b_address, b_household_registration, b_identity, b_identity_issued_by, b_identity_issued_at, b_bank_account, b_bank, b_tax_code, payment_method, n_copies, created_at_place, content, status, created_at, updated_at, created_by, updated_by FROM "contracts" WHERE "rental_id" = $1
`

func (q *Queries) GetContractByRentalID(ctx context.Context, rentalID int64) (Contract, error) {
	row := q.db.QueryRow(ctx, getContractByRentalID, rentalID)
	var i Contract
	err := row.Scan(
		&i.ID,
		&i.RentalID,
		&i.AFullname,
		&i.ADob,
		&i.APhone,
		&i.AAddress,
		&i.AHouseholdRegistration,
		&i.AIdentity,
		&i.AIdentityIssuedBy,
		&i.AIdentityIssuedAt,
		&i.ADocuments,
		&i.ABankAccount,
		&i.ABank,
		&i.ARegistrationNumber,
		&i.BFullname,
		&i.BOrganizationName,
		&i.BOrganizationHqAddress,
		&i.BOrganizationCode,
		&i.BOrganizationCodeIssuedAt,
		&i.BOrganizationCodeIssuedBy,
		&i.BDob,
		&i.BPhone,
		&i.BAddress,
		&i.BHouseholdRegistration,
		&i.BIdentity,
		&i.BIdentityIssuedBy,
		&i.BIdentityIssuedAt,
		&i.BBankAccount,
		&i.BBank,
		&i.BTaxCode,
		&i.PaymentMethod,
		&i.NCopies,
		&i.CreatedAtPlace,
		&i.Content,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getRentalContractsOfUser = `-- name: GetRentalContractsOfUser :many
SELECT id FROM "contracts" 
WHERE
  EXISTS (
    SELECT 1 FROM rentals WHERE 
      rentals.id = contracts.rental_id AND (
        rentals.tenant_id = $3
        OR EXISTS (
          SELECT 1 FROM property_managers WHERE property_managers.property_id = rentals.property_id AND manager_id = $3
        )
      )
  )
LIMIT $1 OFFSET $2
`

type GetRentalContractsOfUserParams struct {
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetRentalContractsOfUser(ctx context.Context, arg GetRentalContractsOfUserParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, getRentalContractsOfUser, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pingContractByRentalID = `-- name: PingContractByRentalID :one
SELECT id, rental_id, status, updated_by, updated_at FROM "contracts" WHERE "rental_id" = $1
`

type PingContractByRentalIDRow struct {
	ID        int64          `json:"id"`
	RentalID  int64          `json:"rental_id"`
	Status    CONTRACTSTATUS `json:"status"`
	UpdatedBy uuid.UUID      `json:"updated_by"`
	UpdatedAt time.Time      `json:"updated_at"`
}

func (q *Queries) PingContractByRentalID(ctx context.Context, rentalID int64) (PingContractByRentalIDRow, error) {
	row := q.db.QueryRow(ctx, pingContractByRentalID, rentalID)
	var i PingContractByRentalIDRow
	err := row.Scan(
		&i.ID,
		&i.RentalID,
		&i.Status,
		&i.UpdatedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const updateContract = `-- name: UpdateContract :exec
UPDATE "contracts" SET
  a_fullname = coalesce($2, a_fullname),
  a_dob = coalesce($3, a_dob),
  a_phone = coalesce($4, a_phone),
  a_address = coalesce($5, a_address),
  a_household_registration = coalesce($6, a_household_registration),
  a_identity = coalesce($7, a_identity),
  a_identity_issued_by = coalesce($8, a_identity_issued_by),
  a_identity_issued_at = coalesce($9, a_identity_issued_at),
  a_documents = coalesce($10, a_documents),
  a_bank_account = coalesce($11, a_bank_account),
  a_bank = coalesce($12, a_bank),
  a_registration_number = coalesce($13, a_registration_number),
  
  b_fullname = coalesce($14, b_fullname),
  b_organization_name = coalesce($15, b_organization_name),
  b_organization_hq_address = coalesce($16, b_organization_hq_address),
  b_organization_code = coalesce($17, b_organization_code),
  b_organization_code_issued_at = coalesce($18, b_organization_code_issued_at),
  b_organization_code_issued_by = coalesce($19, b_organization_code_issued_by),
  b_dob = coalesce($20, b_dob),
  b_phone = coalesce($21, b_phone),
  b_address = coalesce($22, b_address),
  b_household_registration = coalesce($23, b_household_registration),
  b_identity = coalesce($24, b_identity),
  b_identity_issued_by = coalesce($25, b_identity_issued_by),
  b_identity_issued_at = coalesce($26, b_identity_issued_at),
  b_bank_account = coalesce($27, b_bank_account),
  b_bank = coalesce($28, b_bank),
  b_tax_code = coalesce($29, b_tax_code),
  
  payment_method = coalesce($30, payment_method),
  n_copies = coalesce($31, n_copies),
  created_at_place = coalesce($32, created_at_place),
  
  content = coalesce($33, content),
  updated_at = NOW(),
  updated_by = $34
WHERE id = $1
`

type UpdateContractParams struct {
	ID                        int64       `json:"id"`
	AFullname                 pgtype.Text `json:"a_fullname"`
	ADob                      pgtype.Date `json:"a_dob"`
	APhone                    pgtype.Text `json:"a_phone"`
	AAddress                  pgtype.Text `json:"a_address"`
	AHouseholdRegistration    pgtype.Text `json:"a_household_registration"`
	AIdentity                 pgtype.Text `json:"a_identity"`
	AIdentityIssuedBy         pgtype.Text `json:"a_identity_issued_by"`
	AIdentityIssuedAt         pgtype.Date `json:"a_identity_issued_at"`
	ADocuments                []string    `json:"a_documents"`
	ABankAccount              pgtype.Text `json:"a_bank_account"`
	ABank                     pgtype.Text `json:"a_bank"`
	ARegistrationNumber       pgtype.Text `json:"a_registration_number"`
	BFullname                 pgtype.Text `json:"b_fullname"`
	BOrganizationName         pgtype.Text `json:"b_organization_name"`
	BOrganizationHqAddress    pgtype.Text `json:"b_organization_hq_address"`
	BOrganizationCode         pgtype.Text `json:"b_organization_code"`
	BOrganizationCodeIssuedAt pgtype.Date `json:"b_organization_code_issued_at"`
	BOrganizationCodeIssuedBy pgtype.Text `json:"b_organization_code_issued_by"`
	BDob                      pgtype.Text `json:"b_dob"`
	BPhone                    pgtype.Text `json:"b_phone"`
	BAddress                  pgtype.Text `json:"b_address"`
	BHouseholdRegistration    pgtype.Text `json:"b_household_registration"`
	BIdentity                 pgtype.Text `json:"b_identity"`
	BIdentityIssuedBy         pgtype.Text `json:"b_identity_issued_by"`
	BIdentityIssuedAt         pgtype.Date `json:"b_identity_issued_at"`
	BBankAccount              pgtype.Text `json:"b_bank_account"`
	BBank                     pgtype.Text `json:"b_bank"`
	BTaxCode                  pgtype.Text `json:"b_tax_code"`
	PaymentMethod             pgtype.Text `json:"payment_method"`
	NCopies                   pgtype.Int4 `json:"n_copies"`
	CreatedAtPlace            pgtype.Text `json:"created_at_place"`
	Content                   pgtype.Text `json:"content"`
	UserID                    uuid.UUID   `json:"user_id"`
}

func (q *Queries) UpdateContract(ctx context.Context, arg UpdateContractParams) error {
	_, err := q.db.Exec(ctx, updateContract,
		arg.ID,
		arg.AFullname,
		arg.ADob,
		arg.APhone,
		arg.AAddress,
		arg.AHouseholdRegistration,
		arg.AIdentity,
		arg.AIdentityIssuedBy,
		arg.AIdentityIssuedAt,
		arg.ADocuments,
		arg.ABankAccount,
		arg.ABank,
		arg.ARegistrationNumber,
		arg.BFullname,
		arg.BOrganizationName,
		arg.BOrganizationHqAddress,
		arg.BOrganizationCode,
		arg.BOrganizationCodeIssuedAt,
		arg.BOrganizationCodeIssuedBy,
		arg.BDob,
		arg.BPhone,
		arg.BAddress,
		arg.BHouseholdRegistration,
		arg.BIdentity,
		arg.BIdentityIssuedBy,
		arg.BIdentityIssuedAt,
		arg.BBankAccount,
		arg.BBank,
		arg.BTaxCode,
		arg.PaymentMethod,
		arg.NCopies,
		arg.CreatedAtPlace,
		arg.Content,
		arg.UserID,
	)
	return err
}

const updateContractContent = `-- name: UpdateContractContent :exec
UPDATE "contracts" SET
  content = coalesce($2, content),
  status = $3,
  updated_at = NOW(),
  updated_by = $4
WHERE id = $1
`

type UpdateContractContentParams struct {
	ID      int64          `json:"id"`
	Content pgtype.Text    `json:"content"`
	Status  CONTRACTSTATUS `json:"status"`
	UserID  uuid.UUID      `json:"user_id"`
}

func (q *Queries) UpdateContractContent(ctx context.Context, arg UpdateContractContentParams) error {
	_, err := q.db.Exec(ctx, updateContractContent,
		arg.ID,
		arg.Content,
		arg.Status,
		arg.UserID,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: listing.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkListingExpired = `-- name: CheckListingExpired :one
SELECT expired_at < NOW() AND NOT active FROM listings WHERE id = $1 LIMIT 1
`

func (q *Queries) CheckListingExpired(ctx context.Context, id uuid.UUID) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, checkListingExpired, id)
	var column_1 pgtype.Bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkListingOwnership = `-- name: CheckListingOwnership :one
SELECT count(*) FROM listings WHERE id = $1 AND creator_id = $2 LIMIT 1
`

type CheckListingOwnershipParams struct {
	ID        uuid.UUID `json:"id"`
	CreatorID uuid.UUID `json:"creator_id"`
}

func (q *Queries) CheckListingOwnership(ctx context.Context, arg CheckListingOwnershipParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkListingOwnership, arg.ID, arg.CreatorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const checkListingVisibility = `-- name: CheckListingVisibility :one
SELECT count(*) > 0
FROM listings INNER JOIN property_managers ON listings.property_id = property_managers.property_id
WHERE listings.id = $1 
	AND (
		property_managers.manager_id = $2
	OR (
		listings.active AND listings.expired_at > NOW()
	)
	)
LIMIT 1
`

type CheckListingVisibilityParams struct {
	ID        uuid.UUID `json:"id"`
	ManagerID uuid.UUID `json:"manager_id"`
}

func (q *Queries) CheckListingVisibility(ctx context.Context, arg CheckListingVisibilityParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkListingVisibility, arg.ID, arg.ManagerID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkValidUnitForListing = `-- name: CheckValidUnitForListing :one
SELECT count(*) FROM units WHERE units.id = $1 AND units.property_id IN (SELECT listings.property_id FROM listings WHERE listings.id = $2) LIMIT 1
`

type CheckValidUnitForListingParams struct {
	ID   uuid.UUID `json:"id"`
	ID_2 uuid.UUID `json:"id_2"`
}

func (q *Queries) CheckValidUnitForListing(ctx context.Context, arg CheckValidUnitForListingParams) (int64, error) {
	row := q.db.QueryRow(ctx, checkValidUnitForListing, arg.ID, arg.ID_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createListing = `-- name: CreateListing :one
INSERT INTO listings (
  creator_id,
  property_id,
  title,
  description,
  full_name,
  email,
  phone,
  contact_type,
  price,
  price_negotiable,
  security_deposit,
  lease_term,
  pets_allowed,
  number_of_residents,
  priority,
  created_at,
  updated_at,
  expired_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  NOW(), NOW(), 
  NOW() + (INTERVAL'1 day' * $16)
) RETURNING id, creator_id, property_id, title, description, full_name, email, phone, contact_type, price, price_negotiable, security_deposit, lease_term, pets_allowed, number_of_residents, priority, active, created_at, updated_at, expired_at
`

type CreateListingParams struct {
	CreatorID         uuid.UUID   `json:"creator_id"`
	PropertyID        uuid.UUID   `json:"property_id"`
	Title             string      `json:"title"`
	Description       string      `json:"description"`
	FullName          string      `json:"full_name"`
	Email             string      `json:"email"`
	Phone             string      `json:"phone"`
	ContactType       string      `json:"contact_type"`
	Price             int64       `json:"price"`
	PriceNegotiable   pgtype.Bool `json:"price_negotiable"`
	SecurityDeposit   pgtype.Int8 `json:"security_deposit"`
	LeaseTerm         pgtype.Int4 `json:"lease_term"`
	PetsAllowed       pgtype.Bool `json:"pets_allowed"`
	NumberOfResidents pgtype.Int4 `json:"number_of_residents"`
	Priority          int32       `json:"priority"`
	PostDuration      interface{} `json:"post_duration"`
}

func (q *Queries) CreateListing(ctx context.Context, arg CreateListingParams) (Listing, error) {
	row := q.db.QueryRow(ctx, createListing,
		arg.CreatorID,
		arg.PropertyID,
		arg.Title,
		arg.Description,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.ContactType,
		arg.Price,
		arg.PriceNegotiable,
		arg.SecurityDeposit,
		arg.LeaseTerm,
		arg.PetsAllowed,
		arg.NumberOfResidents,
		arg.Priority,
		arg.PostDuration,
	)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.PropertyID,
		&i.Title,
		&i.Description,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.ContactType,
		&i.Price,
		&i.PriceNegotiable,
		&i.SecurityDeposit,
		&i.LeaseTerm,
		&i.PetsAllowed,
		&i.NumberOfResidents,
		&i.Priority,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const createListingPolicy = `-- name: CreateListingPolicy :one
INSERT INTO listing_policies (
  listing_id,
  policy_id,
  note
) VALUES (
  $1,
  $2,
  $3
) RETURNING listing_id, policy_id, note
`

type CreateListingPolicyParams struct {
	ListingID uuid.UUID   `json:"listing_id"`
	PolicyID  int64       `json:"policy_id"`
	Note      pgtype.Text `json:"note"`
}

func (q *Queries) CreateListingPolicy(ctx context.Context, arg CreateListingPolicyParams) (ListingPolicy, error) {
	row := q.db.QueryRow(ctx, createListingPolicy, arg.ListingID, arg.PolicyID, arg.Note)
	var i ListingPolicy
	err := row.Scan(&i.ListingID, &i.PolicyID, &i.Note)
	return i, err
}

const createListingTag = `-- name: CreateListingTag :one
INSERT INTO listing_tags (
  listing_id,
  tag
) VALUES (
  $1,
  $2
) RETURNING id, listing_id, tag
`

type CreateListingTagParams struct {
	ListingID uuid.UUID `json:"listing_id"`
	Tag       string    `json:"tag"`
}

func (q *Queries) CreateListingTag(ctx context.Context, arg CreateListingTagParams) (ListingTag, error) {
	row := q.db.QueryRow(ctx, createListingTag, arg.ListingID, arg.Tag)
	var i ListingTag
	err := row.Scan(&i.ID, &i.ListingID, &i.Tag)
	return i, err
}

const createListingUnit = `-- name: CreateListingUnit :one
INSERT INTO listing_units (
  listing_id,
  unit_id,
  price
) VALUES (
  $1,
  $2,
  $3
) RETURNING listing_id, unit_id, price
`

type CreateListingUnitParams struct {
	ListingID uuid.UUID `json:"listing_id"`
	UnitID    uuid.UUID `json:"unit_id"`
	Price     int64     `json:"price"`
}

func (q *Queries) CreateListingUnit(ctx context.Context, arg CreateListingUnitParams) (ListingUnit, error) {
	row := q.db.QueryRow(ctx, createListingUnit, arg.ListingID, arg.UnitID, arg.Price)
	var i ListingUnit
	err := row.Scan(&i.ListingID, &i.UnitID, &i.Price)
	return i, err
}

const deleteListing = `-- name: DeleteListing :exec
DELETE FROM listings WHERE id = $1
`

func (q *Queries) DeleteListing(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteListing, id)
	return err
}

const deleteListingPolicies = `-- name: DeleteListingPolicies :exec
DELETE FROM listing_policies WHERE listing_id = $1
`

func (q *Queries) DeleteListingPolicies(ctx context.Context, listingID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteListingPolicies, listingID)
	return err
}

const deleteListingTags = `-- name: DeleteListingTags :exec
DELETE FROM listing_tags WHERE listing_id = $1
`

func (q *Queries) DeleteListingTags(ctx context.Context, listingID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteListingTags, listingID)
	return err
}

const deleteListingUnits = `-- name: DeleteListingUnits :exec
DELETE FROM listing_units WHERE listing_id = $1
`

func (q *Queries) DeleteListingUnits(ctx context.Context, listingID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteListingUnits, listingID)
	return err
}

const getAllRentalPolicies = `-- name: GetAllRentalPolicies :many
SELECT id, policy FROM l_policies
`

func (q *Queries) GetAllRentalPolicies(ctx context.Context) ([]LPolicy, error) {
	rows, err := q.db.Query(ctx, getAllRentalPolicies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LPolicy
	for rows.Next() {
		var i LPolicy
		if err := rows.Scan(&i.ID, &i.Policy); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingByID = `-- name: GetListingByID :one
SELECT id, creator_id, property_id, title, description, full_name, email, phone, contact_type, price, price_negotiable, security_deposit, lease_term, pets_allowed, number_of_residents, priority, active, created_at, updated_at, expired_at FROM listings WHERE id = $1 LIMIT 1
`

func (q *Queries) GetListingByID(ctx context.Context, id uuid.UUID) (Listing, error) {
	row := q.db.QueryRow(ctx, getListingByID, id)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.PropertyID,
		&i.Title,
		&i.Description,
		&i.FullName,
		&i.Email,
		&i.Phone,
		&i.ContactType,
		&i.Price,
		&i.PriceNegotiable,
		&i.SecurityDeposit,
		&i.LeaseTerm,
		&i.PetsAllowed,
		&i.NumberOfResidents,
		&i.Priority,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getListingPolicies = `-- name: GetListingPolicies :many
SELECT listing_id, policy_id, note FROM listing_policies WHERE listing_id = $1
`

func (q *Queries) GetListingPolicies(ctx context.Context, listingID uuid.UUID) ([]ListingPolicy, error) {
	rows, err := q.db.Query(ctx, getListingPolicies, listingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingPolicy
	for rows.Next() {
		var i ListingPolicy
		if err := rows.Scan(&i.ListingID, &i.PolicyID, &i.Note); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingTags = `-- name: GetListingTags :many
SELECT id, listing_id, tag FROM listing_tags WHERE listing_id = $1
`

func (q *Queries) GetListingTags(ctx context.Context, listingID uuid.UUID) ([]ListingTag, error) {
	rows, err := q.db.Query(ctx, getListingTags, listingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingTag
	for rows.Next() {
		var i ListingTag
		if err := rows.Scan(&i.ID, &i.ListingID, &i.Tag); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingUnits = `-- name: GetListingUnits :many
SELECT listing_id, unit_id, price FROM listing_units WHERE listing_id = $1
`

func (q *Queries) GetListingUnits(ctx context.Context, listingID uuid.UUID) ([]ListingUnit, error) {
	rows, err := q.db.Query(ctx, getListingUnits, listingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingUnit
	for rows.Next() {
		var i ListingUnit
		if err := rows.Scan(&i.ListingID, &i.UnitID, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingsOfProperty = `-- name: GetListingsOfProperty :many
SELECT id
FROM listings
WHERE 
  property_id = $1
  AND active = TRUE
  AND CASE
    WHEN $4::BOOLEAN THEN expired_at <= NOW()
    WHEN NOT $4::BOOLEAN THEN expired_at > NOW()
  END
ORDER BY
  created_at DESC
LIMIT $2 OFFSET $3
`

type GetListingsOfPropertyParams struct {
	PropertyID uuid.UUID `json:"property_id"`
	Limit      int32     `json:"limit"`
	Offset     int32     `json:"offset"`
	Expired    bool      `json:"expired"`
}

// Get expired / active listings
func (q *Queries) GetListingsOfProperty(ctx context.Context, arg GetListingsOfPropertyParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getListingsOfProperty,
		arg.PropertyID,
		arg.Limit,
		arg.Offset,
		arg.Expired,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateListing = `-- name: UpdateListing :exec
UPDATE listings SET
  title = coalesce($1, title),
  description = coalesce($2, description),
  full_name = coalesce($3, full_name),
  email = coalesce($4, email),
  phone = coalesce($5, phone),
  contact_type = coalesce($6, contact_type),
  price = coalesce($7, price),
  price_negotiable = coalesce($8, price_negotiable),
  security_deposit = coalesce($9, security_deposit),
  lease_term = coalesce($10, lease_term),
  pets_allowed = coalesce($11, pets_allowed),
  number_of_residents = coalesce($12, number_of_residents),
  updated_at = NOW()
  -- post_at = coalesce(sqlc.narg(post_at), post_at)
WHERE id = $13
`

type UpdateListingParams struct {
	Title             pgtype.Text `json:"title"`
	Description       pgtype.Text `json:"description"`
	FullName          pgtype.Text `json:"full_name"`
	Email             pgtype.Text `json:"email"`
	Phone             pgtype.Text `json:"phone"`
	ContactType       pgtype.Text `json:"contact_type"`
	Price             pgtype.Int8 `json:"price"`
	PriceNegotiable   pgtype.Bool `json:"price_negotiable"`
	SecurityDeposit   pgtype.Int8 `json:"security_deposit"`
	LeaseTerm         pgtype.Int4 `json:"lease_term"`
	PetsAllowed       pgtype.Bool `json:"pets_allowed"`
	NumberOfResidents pgtype.Int4 `json:"number_of_residents"`
	ID                uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateListing(ctx context.Context, arg UpdateListingParams) error {
	_, err := q.db.Exec(ctx, updateListing,
		arg.Title,
		arg.Description,
		arg.FullName,
		arg.Email,
		arg.Phone,
		arg.ContactType,
		arg.Price,
		arg.PriceNegotiable,
		arg.SecurityDeposit,
		arg.LeaseTerm,
		arg.PetsAllowed,
		arg.NumberOfResidents,
		arg.ID,
	)
	return err
}

const updateListingPriority = `-- name: UpdateListingPriority :exec
UPDATE listings
SET
  priority = $1,
  updated_at = NOW()
WHERE id = $2
`

type UpdateListingPriorityParams struct {
	Priority int32     `json:"priority"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateListingPriority(ctx context.Context, arg UpdateListingPriorityParams) error {
	_, err := q.db.Exec(ctx, updateListingPriority, arg.Priority, arg.ID)
	return err
}

const updateListingStatus = `-- name: UpdateListingStatus :exec
UPDATE listings 
SET 
  active = $1,
  updated_at = NOW()
 WHERE id = $2
`

type UpdateListingStatusParams struct {
	Active bool      `json:"active"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateListingStatus(ctx context.Context, arg UpdateListingStatusParams) error {
	_, err := q.db.Exec(ctx, updateListingStatus, arg.Active, arg.ID)
	return err
}

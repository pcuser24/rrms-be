// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: reminder.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkReminderVisibility = `-- name: CheckReminderVisibility :one
SELECT EXISTS(SELECT 1 FROM "reminder_members" WHERE "reminder_id" = $1 AND "user_id" = $2)
`

type CheckReminderVisibilityParams struct {
	ReminderID int64     `json:"reminder_id"`
	UserID     uuid.UUID `json:"user_id"`
}

func (q *Queries) CheckReminderVisibility(ctx context.Context, arg CheckReminderVisibilityParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkReminderVisibility, arg.ReminderID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createReminder = `-- name: CreateReminder :one
INSERT INTO "reminders" (
  "creator_id",
  "title",
  "start_at",
  "end_at",
  "note",
  "location",
  "priority",
  "recurrence_day",
  "recurrence_month",
  "recurrence_mode",
  "resource_tag"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11
) RETURNING id, creator_id, title, start_at, end_at, note, location, recurrence_day, recurrence_month, recurrence_mode, priority, status, resource_tag, created_at, updated_at
`

type CreateReminderParams struct {
	CreatorID       uuid.UUID              `json:"creator_id"`
	Title           string                 `json:"title"`
	StartAt         time.Time              `json:"start_at"`
	EndAt           time.Time              `json:"end_at"`
	Note            pgtype.Text            `json:"note"`
	Location        string                 `json:"location"`
	Priority        pgtype.Int4            `json:"priority"`
	RecurrenceDay   pgtype.Int4            `json:"recurrence_day"`
	RecurrenceMonth pgtype.Int4            `json:"recurrence_month"`
	RecurrenceMode  REMINDERRECURRENCEMODE `json:"recurrence_mode"`
	ResourceTag     string                 `json:"resource_tag"`
}

func (q *Queries) CreateReminder(ctx context.Context, arg CreateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, createReminder,
		arg.CreatorID,
		arg.Title,
		arg.StartAt,
		arg.EndAt,
		arg.Note,
		arg.Location,
		arg.Priority,
		arg.RecurrenceDay,
		arg.RecurrenceMonth,
		arg.RecurrenceMode,
		arg.ResourceTag,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.Title,
		&i.StartAt,
		&i.EndAt,
		&i.Note,
		&i.Location,
		&i.RecurrenceDay,
		&i.RecurrenceMonth,
		&i.RecurrenceMode,
		&i.Priority,
		&i.Status,
		&i.ResourceTag,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createReminderMember = `-- name: CreateReminderMember :one
INSERT INTO "reminder_members" (
  "reminder_id",
  "user_id"
) VALUES (
  $1,
  $2
) RETURNING reminder_id, user_id
`

type CreateReminderMemberParams struct {
	ReminderID int64     `json:"reminder_id"`
	UserID     uuid.UUID `json:"user_id"`
}

func (q *Queries) CreateReminderMember(ctx context.Context, arg CreateReminderMemberParams) (ReminderMember, error) {
	row := q.db.QueryRow(ctx, createReminderMember, arg.ReminderID, arg.UserID)
	var i ReminderMember
	err := row.Scan(&i.ReminderID, &i.UserID)
	return i, err
}

const deleteReminder = `-- name: DeleteReminder :exec
DELETE FROM "reminders" WHERE "id" = $1
`

func (q *Queries) DeleteReminder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteReminder, id)
	return err
}

const getReminderById = `-- name: GetReminderById :one
SELECT id, creator_id, title, start_at, end_at, note, location, recurrence_day, recurrence_month, recurrence_mode, priority, status, resource_tag, created_at, updated_at FROM "reminders" WHERE "id" = $1
`

func (q *Queries) GetReminderById(ctx context.Context, id int64) (Reminder, error) {
	row := q.db.QueryRow(ctx, getReminderById, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.Title,
		&i.StartAt,
		&i.EndAt,
		&i.Note,
		&i.Location,
		&i.RecurrenceDay,
		&i.RecurrenceMonth,
		&i.RecurrenceMode,
		&i.Priority,
		&i.Status,
		&i.ResourceTag,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReminderMembers = `-- name: GetReminderMembers :many
SELECT "user_id" FROM "reminder_members" WHERE "reminder_id" = $1
`

func (q *Queries) GetReminderMembers(ctx context.Context, reminderID int64) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getReminderMembers, reminderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var user_id uuid.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRemindersByCreator = `-- name: GetRemindersByCreator :many
SELECT id, creator_id, title, start_at, end_at, note, location, recurrence_day, recurrence_month, recurrence_mode, priority, status, resource_tag, created_at, updated_at FROM "reminders" WHERE "creator_id" = $1
`

func (q *Queries) GetRemindersByCreator(ctx context.Context, creatorID uuid.UUID) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersByCreator, creatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reminder
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Title,
			&i.StartAt,
			&i.EndAt,
			&i.Note,
			&i.Location,
			&i.RecurrenceDay,
			&i.RecurrenceMonth,
			&i.RecurrenceMode,
			&i.Priority,
			&i.Status,
			&i.ResourceTag,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRemindersOfUser = `-- name: GetRemindersOfUser :many
SELECT id, creator_id, title, start_at, end_at, note, location, recurrence_day, recurrence_month, recurrence_mode, priority, status, resource_tag, created_at, updated_at FROM "reminders" WHERE "id" IN (SELECT "reminder_id" FROM "reminder_members" WHERE "user_id" = $1)
`

func (q *Queries) GetRemindersOfUser(ctx context.Context, userID uuid.UUID) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersOfUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reminder
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Title,
			&i.StartAt,
			&i.EndAt,
			&i.Note,
			&i.Location,
			&i.RecurrenceDay,
			&i.RecurrenceMonth,
			&i.RecurrenceMode,
			&i.Priority,
			&i.Status,
			&i.ResourceTag,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRemindersOfUserWithResourceTag = `-- name: GetRemindersOfUserWithResourceTag :many
SELECT id, creator_id, title, start_at, end_at, note, location, recurrence_day, recurrence_month, recurrence_mode, priority, status, resource_tag, created_at, updated_at 
FROM "reminders" 
WHERE 
  "id" IN (SELECT "reminder_id" FROM "reminder_members" WHERE "user_id" = $1)
  AND "resource_tag" = $2
`

type GetRemindersOfUserWithResourceTagParams struct {
	UserID      uuid.UUID `json:"user_id"`
	ResourceTag string    `json:"resource_tag"`
}

func (q *Queries) GetRemindersOfUserWithResourceTag(ctx context.Context, arg GetRemindersOfUserWithResourceTagParams) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersOfUserWithResourceTag, arg.UserID, arg.ResourceTag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reminder
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Title,
			&i.StartAt,
			&i.EndAt,
			&i.Note,
			&i.Location,
			&i.RecurrenceDay,
			&i.RecurrenceMonth,
			&i.RecurrenceMode,
			&i.Priority,
			&i.Status,
			&i.ResourceTag,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReminder = `-- name: UpdateReminder :many
UPDATE "reminders" SET
  "title" = coalesce($2, title),
  "start_at" = coalesce($3, start_at),
  "end_at" = coalesce($4, end_at),
  "note" = coalesce($5, note),
  "location" = coalesce($6, location),
  "priority" = coalesce($7, priority),
  "recurrence_day" = coalesce($8, recurrence_day),
  "recurrence_month" = coalesce($9, recurrence_month),
  "recurrence_mode" = coalesce($10, recurrence_mode),
  "status" = coalesce($11, status)
WHERE 
  "id" = $1 
RETURNING id, creator_id, title, start_at, end_at, note, location, recurrence_day, recurrence_month, recurrence_mode, priority, status, resource_tag, created_at, updated_at
`

type UpdateReminderParams struct {
	ID              int64                      `json:"id"`
	Title           pgtype.Text                `json:"title"`
	StartAt         pgtype.Timestamptz         `json:"start_at"`
	EndAt           pgtype.Timestamptz         `json:"end_at"`
	Note            pgtype.Text                `json:"note"`
	Location        pgtype.Text                `json:"location"`
	Priority        pgtype.Int4                `json:"priority"`
	RecurrenceDay   pgtype.Int4                `json:"recurrence_day"`
	RecurrenceMonth pgtype.Int4                `json:"recurrence_month"`
	RecurrenceMode  NullREMINDERRECURRENCEMODE `json:"recurrence_mode"`
	Status          NullREMINDERSTATUS         `json:"status"`
}

func (q *Queries) UpdateReminder(ctx context.Context, arg UpdateReminderParams) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, updateReminder,
		arg.ID,
		arg.Title,
		arg.StartAt,
		arg.EndAt,
		arg.Note,
		arg.Location,
		arg.Priority,
		arg.RecurrenceDay,
		arg.RecurrenceMonth,
		arg.RecurrenceMode,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reminder
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Title,
			&i.StartAt,
			&i.EndAt,
			&i.Note,
			&i.Location,
			&i.RecurrenceDay,
			&i.RecurrenceMonth,
			&i.RecurrenceMode,
			&i.Priority,
			&i.Status,
			&i.ResourceTag,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

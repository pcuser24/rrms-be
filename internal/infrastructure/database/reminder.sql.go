// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: reminder.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkReminderVisibility = `-- name: CheckReminderVisibility :one
SELECT EXISTS(SELECT 1 FROM "reminders" WHERE "id" = $1 AND "creator_id" = $2)
`

type CheckReminderVisibilityParams struct {
	ID        int64     `json:"id"`
	CreatorID uuid.UUID `json:"creator_id"`
}

func (q *Queries) CheckReminderVisibility(ctx context.Context, arg CheckReminderVisibilityParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkReminderVisibility, arg.ID, arg.CreatorID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createReminder = `-- name: CreateReminder :one
INSERT INTO "reminders" (
  "creator_id",
  "title",
  "start_at",
  "end_at",
  "note",
  "location"
  -- "priority",
  -- "recurrence_day",
  -- "recurrence_month",
  -- "recurrence_mode",
  -- "resource_tag"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
  -- sqlc.narg(priority),
  -- sqlc.narg(recurrence_day),
  -- sqlc.narg(recurrence_month),
  -- sqlc.arg(recurrence_mode),
  -- sqlc.arg(resource_tag)
) RETURNING id, creator_id, title, start_at, end_at, note, location, created_at, updated_at
`

type CreateReminderParams struct {
	CreatorID uuid.UUID   `json:"creator_id"`
	Title     string      `json:"title"`
	StartAt   time.Time   `json:"start_at"`
	EndAt     time.Time   `json:"end_at"`
	Note      pgtype.Text `json:"note"`
	Location  string      `json:"location"`
}

func (q *Queries) CreateReminder(ctx context.Context, arg CreateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, createReminder,
		arg.CreatorID,
		arg.Title,
		arg.StartAt,
		arg.EndAt,
		arg.Note,
		arg.Location,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.Title,
		&i.StartAt,
		&i.EndAt,
		&i.Note,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReminder = `-- name: DeleteReminder :exec
DELETE FROM "reminders" WHERE "id" = $1
`

func (q *Queries) DeleteReminder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteReminder, id)
	return err
}

const getReminderById = `-- name: GetReminderById :one
SELECT id, creator_id, title, start_at, end_at, note, location, created_at, updated_at FROM "reminders" WHERE "id" = $1
`

func (q *Queries) GetReminderById(ctx context.Context, id int64) (Reminder, error) {
	row := q.db.QueryRow(ctx, getReminderById, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.CreatorID,
		&i.Title,
		&i.StartAt,
		&i.EndAt,
		&i.Note,
		&i.Location,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRemindersByCreator = `-- name: GetRemindersByCreator :many
SELECT id, creator_id, title, start_at, end_at, note, location, created_at, updated_at FROM "reminders" WHERE "creator_id" = $1
`

func (q *Queries) GetRemindersByCreator(ctx context.Context, creatorID uuid.UUID) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersByCreator, creatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reminder
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Title,
			&i.StartAt,
			&i.EndAt,
			&i.Note,
			&i.Location,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRemindersInDate = `-- name: GetRemindersInDate :many
SELECT id, creator_id, title, start_at, end_at, note, location, created_at, updated_at FROM "reminders" WHERE DATE_TRUNC('month', start_at) = DATE_TRUNC('month', $1)
`

func (q *Queries) GetRemindersInDate(ctx context.Context, dateTrunc pgtype.Interval) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, getRemindersInDate, dateTrunc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reminder
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Title,
			&i.StartAt,
			&i.EndAt,
			&i.Note,
			&i.Location,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReminder = `-- name: UpdateReminder :many
UPDATE "reminders" SET
  "title" = coalesce($2, title),
  "start_at" = coalesce($3, start_at),
  "end_at" = coalesce($4, end_at),
  "note" = coalesce($5, note),
  "location" = coalesce($6, location),
  -- "priority" = coalesce(sqlc.narg(priority), priority),
  -- "recurrence_day" = coalesce(sqlc.narg(recurrence_day), recurrence_day),
  -- "recurrence_month" = coalesce(sqlc.narg(recurrence_month), recurrence_month),
  -- "recurrence_mode" = coalesce(sqlc.narg(recurrence_mode), recurrence_mode),
  "updated_at" = NOW()
WHERE 
  "id" = $1 
RETURNING id, creator_id, title, start_at, end_at, note, location, created_at, updated_at
`

type UpdateReminderParams struct {
	ID       int64              `json:"id"`
	Title    pgtype.Text        `json:"title"`
	StartAt  pgtype.Timestamptz `json:"start_at"`
	EndAt    pgtype.Timestamptz `json:"end_at"`
	Note     pgtype.Text        `json:"note"`
	Location pgtype.Text        `json:"location"`
}

func (q *Queries) UpdateReminder(ctx context.Context, arg UpdateReminderParams) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, updateReminder,
		arg.ID,
		arg.Title,
		arg.StartAt,
		arg.EndAt,
		arg.Note,
		arg.Location,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reminder
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.CreatorID,
			&i.Title,
			&i.StartAt,
			&i.EndAt,
			&i.Note,
			&i.Location,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
